use std::{
	ffi::c_void,
	marker::PhantomData,
	mem,
};

use libc::size_t;

pub use iter::{VectorIterator, VectorRefIterator};
pub use vector_extern::{VectorElement, VectorExtern, VectorExternCopyNonBool};

use crate::{core::Boxed, Result};

mod vector_extern;
mod iter;

/// Wrapper for C++ [std::vector](https://en.cppreference.com/w/cpp/container/vector)
pub struct Vector<T: VectorElement> where Self: VectorExtern<T> {
	ptr: *mut c_void,
	_d: PhantomData<T>,
}

impl<T: VectorElement> Boxed for Vector<T> where Self: VectorExtern<T> {
	#[inline]
	unsafe fn from_raw(ptr: *mut c_void) -> Self {
		Self { ptr, _d: PhantomData }
	}

	#[inline]
	fn into_raw(self) -> *mut c_void {
		let out = self.ptr;
		mem::forget(self);
		out
	}

	#[inline]
	fn as_raw(&self) -> *const c_void {
		self.ptr
	}

	#[inline]
	fn as_raw_mut(&mut self) -> *mut c_void {
		self.ptr
	}
}

impl<T: VectorElement> Vector<T> where Self: VectorExtern<T> {
	/// Create a new Vector
	pub fn new() -> Self {
		unsafe { Self::from_raw(Self::extern_new()) }
	}

	/// Create a Vector with pre-defined capacity
	pub fn with_capacity(capacity: size_t) -> Self {
		let mut out = Self::new();
		out.reserve(capacity);
		out
	}

	/// Return Vector length
	pub fn len(&self) -> size_t {
		unsafe { self.extern_len() }
	}

	/// Return true if Vector is empty
	pub fn is_empty(&self) -> bool {
		unsafe { self.extern_is_empty() }
	}

	/// Return Vector current capacity
	pub fn capacity(&self) -> size_t {
		unsafe { self.extern_capacity() }
	}

	/// Free extra capacity
	pub fn shrink_to_fit(&mut self) {
		unsafe { self.extern_shrink_to_fit() }
	}

	/// Reserve capacity for `additional` new elements
	pub fn reserve(&mut self, additional: size_t) {
		unsafe { self.extern_reserve(additional) }
	}

	/// Remove all elements
	pub fn clear(&mut self) {
		unsafe { self.extern_clear() }
	}

	/// Remove the element at the specified `index`
	pub fn remove(&mut self, index: size_t) -> Result<()> {
		vector_index_check(index, self.len())?;
		unsafe { self.extern_remove(index) }
		Ok(())
	}

	/// Swap 2 elements in the Vector
	pub fn swap(&mut self, index1: size_t, index2: size_t) -> Result<()> {
		let len = self.len();
		vector_index_check(index1, len)?;
		vector_index_check(index2, len)?;
		if index1 != index2 {
			unsafe { self.extern_swap(index1, index2) }
		}
		Ok(())
	}

	// pub fn push(&mut self, val: T::ArgFuncDecl) {
	// 	unsafe { self.extern_push(val.as_extern()) }
	// }
	//
	// pub fn insert(&mut self, index: size_t, val: T::ArgFuncDecl) -> crate::Result<()> {
	// 	vector_index_check(index, self.len() + 1)?;
	// 	unsafe { self.extern_insert(index, val.as_extern()) }
	// 	Ok(())
	// }
	//
	// pub fn set(&mut self, index: size_t, val: T::ArgFuncDecl) -> Result<()> {
	// 	vector_index_check(index, self.len())?;
	// 	unsafe { self.extern_set(index, val.as_extern()) }
	// 	Ok(())
	// }
	//
	// pub unsafe fn set_unchecked(&mut self, index: size_t, val: T::ArgFuncDecl) {
	// 	self.extern_set(index, val.as_extern())
	// }
	//
	/// Get element at the specified `index`
	pub fn get(&self, index: size_t) -> Result<T> {
		vector_index_check(index, self.len())?;
		unsafe { self.extern_get(index) }
	}

	/// Same as `get()` but without bounds checking
	pub unsafe fn get_unchecked(&self, index: size_t) -> T {
		self.extern_get(index).unwrap() // fixme
	}

	pub fn iter(&self) -> VectorRefIterator<T> {
		VectorRefIterator::new(self)
	}

	pub fn to_slice(&self) -> &[T] where Self: VectorExternCopyNonBool<T> {
		unsafe {
			::std::slice::from_raw_parts(self.extern_data(), self.len())
		}
	}

	pub fn to_vec(&self) -> Vec<T> {
		T::convert_to_vec(self)
	}
}

impl<T: VectorElement> Drop for Vector<T> where Self: VectorExtern<T> {
	fn drop(&mut self) {
		unsafe { self.extern_delete() }
	}
}

/// Common interface for all C++ vector types generated by the crate
///
/// You'll need to import this trait to use any of the C++ vector wrappers, usually imported as
/// part of the prelude.
pub trait VectorTrait<'i>: Sized {
	type Arg;

	fn with_capacity(capacity: size_t) -> Self;

	/// Create a Vector from iterator
	fn from_iter(s: impl IntoIterator<Item=Self::Arg>) -> Self {
		let s = s.into_iter();
		let (lo, hi) = s.size_hint();
		let mut out = Self::with_capacity(hi.unwrap_or(lo));
		s.for_each(|x| out.push(x));
		out
	}

	/// Add new element
	fn push(&mut self, val: Self::Arg);

	/// Insert a new element at the specified `index`
	fn insert(&mut self, index: size_t, val: Self::Arg) -> crate::Result<()>;

	/// Set element at the specified `index`
	fn set(&mut self, index: size_t, val: Self::Arg) -> crate::Result<()>;

	/// Same as `set()` but without bounds checking
	unsafe fn set_unchecked(&mut self, index: size_t, val: Self::Arg);
}

#[inline(always)]
pub(crate) fn vector_index_check(index: size_t, len: size_t) -> crate::Result<()> {
	if index >= len {
		Err(crate::Error::new(crate::core::StsOutOfRange, format!("Index: {} out of bounds: 0..{}", index, len)))
	} else {
		Ok(())
	}
}
